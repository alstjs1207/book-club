## TIL (2023.06.14)

### DAY 15

오늘 읽은 범위: 시작 - 5장) any 다루기 - 아이템 38 ~ 아이템 40

---

```
😉 책에서 기억하고 싶은 내용을 써보세요.
```

- 타입스크립트의 타입 시스템은 선택적(optional)이고 점진적(gradual)이기 때문에 정적이면서도 동적인 특성을 동시에 가집니다.
- any의 장점은 살리면서 단점을 줄이는 방법들을 살펴보겠습니다.

### 아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기

- x: any 보다 x as any 형태가 권장됩니다. 그 이유는 any 타입이 함수의 매개변수에서만 사용된 표현식이므로 다른 코드에는
  영향을 미치지 않기 때문입니다.
- any 타입을 반환한다면 문제가 커집니다.

```
function f1() {
  const x: any = expressionReturningFoo();
  processBar(x);
  return x;
}

function f2() {
  const x = expressionReturningFoo();
  processBar(x as any);
}
function g() {
  const foo = f1(); // 타입이 any
  foo.fooMethod();
}
```

- g 함수 내에서 f1이 사용되므로 f1의 반환 타입인 any 타입이 foo의 타입에 영향을 미칩니다. 이렇게 함수에서 any를
  반환하면 그 영향력은 프로젝트 전반에 전염병처럼 퍼지게 됩니다. 반면 any의 사용 범위를 좁게 제한하는 f2 함수를 사용한다면
  any타입이 함수 바깥으로 영향을 미치지 않습니다.
- 객체 전체를 any로 단언하면 다른 속성들 역시 타입 체크가 되지 않는 부작용이 생깁니다. 최소한의 범위에만 any를 사용하는 것이
  좋습니다.

### 아이템 39 any를 구체적으로 변형해서 사용하기

- any 타입의 값을 그대로 정규식이나 함수에 넣는 것은 권장되지 않습니다.

  - 구체적인 타입 입력
  - 객체이긴 하지만 값을 알 수 없다면 : {[k: string]: any} or object
  - 객체지만 속성에 접근할 수 없어야 한다면 : unknown

- any로 선언해도 동작하지만 any[]로 선언하면 배열 형태라는 것을 알수 있어 더 구체적입니다.

```
const numArgsBad = (...args: any) => args.length; // any를 반환합니다.
const numArgsGood = (...args: any[]) => args.length; // number를 반환합니다.
```

### 아이템 40 함수 안으로 타입 단언문 감추기

- 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는게 낫습니다.
  프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을
  감추는 것이 더 좋은 설계입니다.
- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 합니다.
  불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 합니다.

```
🤔 오늘 익은 소감은? 떠오르는 생각을 가볍게 적어보세요
```

- any를 어쩔 수 없이 사용할 때, any[] 처럼 구체적으로 사용하는 방법이 있는지 알게되었다. 만약 사용한다면 구체적으로 사용하는 것이
  좋겠다.
- x: any 보다 x as any로 사용하도록 해야겠다.
- 사실 any는 최대한 사용하지 않는 것이 좋겠다.

```
궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
```

## TIL (2023.08.13)

### DAY 3

오늘 읽은 범위: 시작 - 4장) 액션에서 계산 빼내기

---

```
😉 책에서 기억하고 싶은 내용을 써보세요.
```

## 예시 코드를 살펴볼까요?

절차적인 방법으로 구현해보면:

```
let shopping_cart_total: number = 0;
let shopping_cart = [
    {
        name: 'shirts',
        price: 10,
    },
    {
        name: 'shoes',
        price: 15,
    }
];

function calc_cart_total () {
  shopping_cart_total = 0;
  for(let i = 0; i < shopping_cart.length; i++) {
        const item = shopping_cart[i];
        shopping_cart_total += item.price;
    }

  set_cart_total_dom(); // 금액 합계를 반영하기 위해 DOM 업데이트
}

calc_cart_total(); // 25

```

### 테스트하기가 쉽지 않은데?

코드가 바뀔 때마다 아래와 같은 테스트를 만들어야 해요:

- 브라우저 설정
- 페이지 로드
- 장바구니에 제품 담기 버튼 클릭
- DOM 업데이트 및 값 가져오기
- 예상하는 값과 비교

### 그럼 어떻게 해야 테스트하기 용이할까?

쉽게 하려면 다음과 같은 조건이 필요해요:

- DOM 업데이트와 비즈니스 규칙은 분리해야 해!
- 전역변수는 없어야 해!

### 코드를 재사용도 어려운데 어떻게 해야 할까?

재사용 하려면 아래와 같은 조건이 필요해요:

- 전역변수에 의존하지 않아야 해!
- DOM을 사용할 수 있는 곳에서 실행된다고 가정하면 안돼!
- 함수가 결괏값을 리턴해야 해!

## 액션과 계산, 데이터를 구분해보자

현재 예시의 코드에는 모든 코드가 `액션`으로 구성되어있어요.
살펴보면:

- **shopping_cart_total, shopping_cart** : 전역변수이고 변경 가능하기 때문에 `액션`
- **shopping_cart_total = 0;**: 전역변수를 바꾸는 것도 `액션`

**기억하세요**: 함수 안에 액션이 하나 있다면 그 `함수 전체가 액션`이 됩니다.

## 여기서 잠깐! 함수에는 입력과 출력이 있습니다

입력은 함수가 계산을 하기위한 외부 정보입니다. 출력은 함수 밖으로 나오는 정보나 어떤 동작입니다.
그리고 입력과 출력은 명시적이거나 암묵적일 수 있습니다.

### 명시적, 암묵적 차이가 뭐야?

간단히 살펴보면:

- 명시적 입력 -> 인자
- 명시적 출력 -> 리턴값
- 암묵적 입력 -> 인자 외 다른 입력
- 암묵적 출력 -> 리턴값 외 다른 출력

**`여기서 중요한건 함수에 암묵적 입력과 출력이 있으면 액션이 됩니다.`**

그래서 우리는 이렇게 해야합니다:

- 암묵적 입력은 함수의 인자로 변경
- 암묵적 출력은 함수의 리턴값으로 변경

## 위에서 이야기한 테스트와 재사용성이 왜 어려운가 기억하지?

왜 어렵고 어떻게 해야하는지 제안한 건 모두 `암묵적 입력과 출력을 없애야 한다`고 말하는 거애요.

## 액션에서 계산을 빼보자

예시 코드에서 액션 -> 계산을 빼보면:

```
const shopping_cart = [
    {
        name: 'shirts',
        price: 10,
    },
    {
        name: 'shoes',
        price: 15,
    }
];

function calc_cart_total () {
 const shopping_cart_total = calc_total(shopping_cart);
 set_cart_total_dom(); // 금액 합계를 반영하기 위해 DOM 업데이트
}

function calc_total (cart: any) {
    let total = 0;
    for(let i =0; i < cart.length; i++) {
        const item = cart[i];
        total += item.price;
    }

return total;
}

calc_cart_total(); // 25

```

지금 한 리팩터링은 `서브루틴 추출하기` 라고 할 수 있습니다.

### 무엇이 변경되었을까요?

- 암묵적인 입출력이 명시적인 입출력으로 변경되었어요.
- 전역변수 대신 지역변수를 사용하도록 변경하였어요.
- 원래의 함수는 새 함수의 리턴값을 받아 전역변수에 할당하였어요.

### 앞으로 어떻게 하면 될까?

액션에서 계산을 빼내는 작업을 살펴보면:

- 계산 코드를 찾아냄 -> 새 함수에 암묵적 입출력을 찾아냄 -> 암묵적 입력은 인자로 암묵적 출력은 리턴값으로 변경

```
🤔 오늘 익은 소감은? 떠오르는 생각을 가볍게 적어보세요
```

- 명시적, 암묵적 입출력의 차이을 알게 되었다.
- 가장 기본적인 리팩토링이다. -> 서브루틴 추출하기
- if를 통한 분기와 filter를 이용해 결과를 return한 후 계산하는 방식은 차이가 명확하다.

```
궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
```

- copy-on-write: 어떤 값을 바꿀 때 그 값을 복사해서 바꾸는 방법은 불변성을 구현하는 방법 중 하나입니다.
- 기존 배열에 데이터를 추가할때, 배열을 복사(slice)한 다음 데이터를 추가하고 리턴하는 작업을 하였는데 왜일까?
  -> 책에서 설명했듯이 불변성을 지키기 위한 방식일 뿐... 효율성과는 거리가 멀다고 생각한다.
  해당 이슈는 함수형 프로그래밍과 거리가 멀다.
  사이드이펙트를 줄이기 위함.
- P.77 내용 : 계산으로 바꾼 함수 안에서 아직도 변수를 변경하고 있습니다. 함수형 프로그래밍에서는 모든 것이 불변값이어야 한다고 들었는데요.
  어떻게 설명할 수 있나요? 의 답변이 이해가 안됨.
  답변: 불변값은 생성된 다음에 바뀌면 안 되는 값입니다. 하지만 생성할 때는 초기화가 필요합니다. 만약 초깃값이 있어야 하는 배열이 필요하고
  이후에 바뀌지 않는다고 해도 초깃값을 넣기 위해 시작 부분에 값을 배열에 넣어줘야합니다.
  지역변수를 변경하는 곳은 나중에 초기화할 값으로 새로 생성합니다. 지역변수이기 때문에 함수 밖에서는 접근할 수 없습니다.
  그리고 초기화가 끝났다면 그 값은 리턴해야 합니다. 이처럼 값이 바뀌지 않으려면 원칙이 필요한데 자세한 내용은 6장에..
